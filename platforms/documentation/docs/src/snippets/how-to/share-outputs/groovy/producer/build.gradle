// tag::java-lib[]
plugins {
    id("java-library")
}
// end::java-lib[]

// tag::instrumentedjar-task[]
// Register a custom JAR task that packages the output of the 'main' source set.
// This JAR will have a classifier of 'instrumented' to distinguish it from the default artifact.
def instrumentedJar = tasks.register("instrumentedJar", Jar) {
    archiveClassifier.set("instrumented")
    from(sourceSets.main.output)
    // Additional instrumentation processing could go here
}
// end::instrumentedjar-task[]

// tag::custom-config[]
configurations {
    // Create a custom consumable configuration named 'instrumentedJars'
    // This allows other projects to depend on the instrumented JAR variant
    create("instrumentedJars") {
        canBeConsumed = true
        canBeResolved = false

        // Assign attributes so that consuming projects can match on these
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
            // The defining attribute
            attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, "instrumented-jar"))
        }
    }
}

// Publish the custom JAR artifact to the 'instrumentedJars' configuration
artifacts {
    add("instrumentedJars", instrumentedJar)
}
// end::custom-config[]
