// Copyright (C) 2025 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[binary_plugins_advanced]]
= Binary Plugins

If Gradle or the Gradle community does not offer the specific capabilities your project needs, creating your own custom plugin could be a solution.
This is where binary plugins come in.

A binary plugin is a plugin that is implemented in a compiled language and is packaged as a JAR file.

== Implementing the Plugin Interface

All plugins, aside from pre-compiled script plugins, must implements the link:{javadocPath}/org/gradle/api/Plugin.html[`Plugin`] interface.

For example, this is a "hello world" *plugin*:

====
include::sample[dir="snippets/plugins/simple/kotlin", files="build.gradle.kts[tags=plugin]"]
include::sample[dir="snippets/plugins/simple/groovy", files="build.gradle[tags=plugin]"]
====
<1> Extend the `org.gradle.api.Plugin` interface.
<2> Override the `apply` method.
<3> `apply` the plugin to the project.

=== 1. Extend the `org.gradle.api.Plugin` interface

Create a class that extends the `Plugin` interface:

====
[.multi-language-sample]
=====
.build.gradle.kts
[source, kotlin]
----
abstract class SamplePlugin : Plugin<Project> {
}
----
=====
[.multi-language-sample]
=====
.build.gradle
[source,groovy]
----
class SamplePlugin implements Plugin<Project> {
}
----
=====
====

=== 2. Override the `apply` method

Add tasks and other logic in the `apply()` method:

====
[.multi-language-sample]
=====
.build.gradle.kts
[source, kotlin]
----
override fun apply() {

}
----
=====
[.multi-language-sample]
=====
.build.gradle
[source,groovy]
----
void apply(Project project) {

}
----
=====
====

=== 3. `apply` the plugin to your project

When `SamplePlugin` is applied in your project, Gradle calls the `fun apply() {}` method defined.
This adds the `ScriptPlugin` task to your project:

====
[.multi-language-sample]
=====
.build.gradle.kts
[source, kotlin]
----
apply<SamplePlugin>()
----
=====
[.multi-language-sample]
=====
.build.gradle
[source,groovy]
----
apply plugin: SamplePlugin
----
=====
====

== Developing a Binary Plugin

There are two ways to update the convention plugin in the previous page into a binary plugin.

1. Use <<composite_builds.adoc#composite_builds,composite builds>>:
+
.settings.gradle.kts
[source,kotlin]
----
includeBuild("my-plugin")
----

2. <<publishing_gradle_plugins.adoc#sec:publishing_your_plugin,Publish the plugin>> to a repository:
+
.build.gradle.kts
[source,kotlin]
----
plugins {
    id("com.gradle.plugin.my-plugin") version "1.0.0"
}
----

Let's go with the second solution.

This plugin has been re-written in Kotlin and is called `MyCreateFileBinaryPlugin.kt`.
It is still stored in `buildSrc`:

====
include::sample[dir="snippets/plugins/simple/kotlin", files="buildSrc/src/main/kotlin/MyCreateFileBinaryPlugin.kt[]"]
====

The plugin can be published and given an `id` using a `gradlePlugin{}` block so that it can be referenced in the root:

====
include::sample[dir="snippets/plugins/simple/kotlin", files="buildSrc/build.gradle.kts[tags=plugin-3]"]
include::sample[dir="snippets/plugins/simple/groovy", files="buildSrc/build.gradle[tags=plugin-3]"]
====

Then, the plugin can be applied in the build file:

====
include::sample[dir="snippets/plugins/simple/kotlin", files="build.gradle.kts[tags=apply]"]
include::sample[dir="snippets/plugins/simple/groovy", files="build.gradle[tags=apply]"]
====

Ready to build something? Start with the Advanced Tutorial.

Next Step: Start the Tutorial >>
