// Copyright (C) 2025 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[pre_compiled_script_plugins_advanced]]
= Pre-compiled Script Plugins

The simplest plugin you can develop is called a *precompiled script plugins*.

These are Kotlin (`.kts`) or Groovy (`.gradle`) scripts.
They behave like normal Gradle plugins, but you write them using the same syntax as regular build scripts.

Some benefits of *precompiled script plugins*:

* **Encapsulation**: Keep your `build.gradle(.kts)` files clean by moving reusable logic into named plugins.
* **Tooling support**: Full IDE support, like autocomplete and navigation.
* **Avoid boilerplate**: No need to write full plugin classes or register plugins manually.
* **Faster adoption**: Use familiar script syntax while reaping the benefits of structured plugin development.

== Convention Plugins

Most *precompiled script plugins* are used as *convention plugins*.
A Gradle term for reusable build logic that applies standard plugin configurations, defaults, and behaviors across many projects.

*Convention plugins* are especially useful in large or multi-project builds where consistency is important.

== Structuring Precompiled Script Plugins

Precompiled script plugins are typically placed in either:

1. A dedicated `buildSrc` directory in your build, or
2. A separate included build (often named `build-logic`).

=== 1. Using `buildSrc`

**Precompiled script plugins** or **convention plugins** will often be found in the special `buildSrc` directory:

====
[.multi-language-sample]
=====
[source, kotlin]
----
.
└── buildSrc
    ├── build.gradle.kts
    └── src
       └── main
          └── kotlin
             └── precompiled-script-plugin.gradle.kts
----
=====
[.multi-language-sample]
=====
[source, groovy]
----
.
└── buildSrc
    ├── build.gradle
    └── src
       └── main
          └── groovy
             └── precompiled-script-plugin.gradle
----
=====
====

=== 2. Using a Composite Build

**Precompiled script plugins** or **convention plugins** will often be found in a composite build with a name similar to `build-logic`:

====
[.multi-language-sample]
=====
[source, kotlin]
----
build-logic
├── settings.gradle.kts
├── build.gradle.kts
└── src
   └── main
      └── kotlin
         └── precompiled-script-plugin.gradle.kts
----
=====
[.multi-language-sample]
=====
[source, groovy]
----
build-logic
├── settings.gradle
├── build.gradle
└── src
   └── main
      └── groovy
         └── precompiled-script-plugin.gradle
----
=====
====

== Applying a Precompiled Script Plugin

You apply a precompiled script plugin using its ID, derived from the script filename (excluding the `.gradle.kts` or `.gradle` extension).

[source,kotlin]
----
plugins {
    id("my-convention-plugin")
}
----

The script itself acts as the plugin.
There is no need to explicitly implement the link:{javadocPath}/org/gradle/api/Plugin.html[`Plugin`] interface.

== Publishing a Precompiled Script Plugin

You can publish a precompiled script plugin to a repository, either a public (like the link:https://plugins.gradle.org/[Gradle Plugin Portal]) or a private artifact repository (e.g., Maven, Artifactory, Nexus).
However, this is not typical for most builds.

== Example of a Precompiled Script Plugin

Let's take a look at an example of a convention plugin in `buildSrc`.

=== 1. Create a `buildSrc` directory

In your project root, add a `buildSrc` directory:

====
[.multi-language-sample]
=====
[source, kotlin]
----
.                           // root project
├── ...                     // other project dirs and files
└── buildSrc
    ├── build.gradle.kts
    └── src
       └── main
          └── kotlin
----
=====
[.multi-language-sample]
=====
[source, groovy]
----
.                           // root project
├── ...                     // other project dirs and files
└── buildSrc
    ├── build.gradle
    └── src
       └── main
          └── groovy
----
=====
====

=== 2. Add a build file

The `build.gradle(.kts)` should contain whatever you need to create the pre-compiled script plugin:

====
include::sample[dir="snippets/plugins/simple/kotlin", files="buildSrc/build.gradle.kts[]"]
include::sample[dir="snippets/plugins/simple/groovy", files="buildSrc/build.gradle[]"]
====

=== 3. Create a plugin script

Inside `build-logic/src/main/kotlin` or `build-logic/src/main/groovy`, write a `.gradle(.kts)` file.
For example:

[source,text]
----
.
└── buildSrc
    ├── build.gradle.kts
    └── src
       └── main
          └── kotlin
             └── my-create-file-plugin.gradle.kts
----

Our `my-create-file-plugin.gradle.kts` file contains the following code:

====
include::sample[dir="snippets/plugins/simple/kotlin", files="buildSrc/src/main/kotlin/my-create-file-plugin.gradle.kts[]"]
include::sample[dir="snippets/plugins/simple/groovy", files="buildSrc/src/main/groovy/my-create-file-plugin.gradle[]"]
====

The name of the script (`my-create-file-plugin.gradle(.kts)`) becomes the plugin ID: `my-create-file-pluginy`.

=== 4. Apply the plugin in your project

The pre-compiled script can now be applied in the `build.gradle(.kts`) file of any subproject:

====
include::sample[dir="snippets/plugins/simple/kotlin", files="build.gradle.kts[tags=apply-conv]"]
include::sample[dir="snippets/plugins/simple/groovy", files="build.gradle[tags=apply-conv]"]
====

The `createMyFileTaskInConventionPlugin` task from the plugin is now available.

[.text-right]
**Next Step:** <<binary_plugin_advanced.adoc#binary_plugins_advanced,Learn about Binary Plugins>> >>
