// Copyright (C) 2024 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[part5_add_dataflow_action]]
= Part 5: Add a DataFlow Action

Learn the basics of DataFlow Actions to hook into the Gradle build lifecycle and add it to your plugin.

****
**In this section, you will:**

- Understand DataFlow Action
- Add a DataFlow Action to the Plugin
****

[[part5_begin]]
== Step 0. Before you Begin

1. You initialized your plugin in <<part1_gradle_init_plugin.adoc#part1_begin,part 1>>.
2. You added an extension to your plugin in <<part2_add_extension.adoc#part2_begin,part 2>>.
3. You created a custom task in <<part3_create_custom_task.adoc#part3_begin, part3>>.
4. You wrote a unit test in <<part4_unit_test.adoc#part4_begin,part 4>>.

== Step 1. Understanding DataFlow Actions

Dataflow Actions in Gradle are a modern mechanism for reacting to the build lifecycle and exchanging data between Gradle components without relying on traditional build listeners, task dependencies, or plugin ordering.

They are part of Gradle’s configuration cache-friendly, isolated, and lazy architecture, introduced to support more reliable and scalable plugin behavior.

A Dataflow Action is a unit of logic that executes in response to a particular state or event during the build lifecycle.

They are:

* *Declarative* – You register what should happen and when, but Gradle controls when and how it runs.
* *Isolated* – The inputs are explicitly declared, and actions are executed with only those inputs.
* *Safe for Configuration Cache* – Unlike `BuildListener`, these actions are designed to integrate cleanly with the Configuration Cache.

There are three important components of a Flow Action:

* *`FlowScope`* – A service that lets you register flow actions to be triggered under certain conditions (e.g., build finished).
* *`FlowAction<T>`* – An interface you implement to define the action that runs.
* *`FlowParameters`* – A container for the inputs to the action (must be Property<T> or service references).

== Step 2. Creating a DataFlow Action

[.multi-language-text.lang-kotlin]
----
If you want to send a Slack notification when the build finishes, you can write a `SlackBuildFlowAction` in `plugin/src/kotlin/org/example/SlackBuildFlowAction.kt`.
----
[.multi-language-text.lang-groovy]
----
If you want to send a Slack notification when the build finishes, you can write a `SlackBuildFlowAction` in `plugin/src/groovy/org/example/SlackBuildFlowAction.groovy`.
----

Create this new file and add the following code:

====
include::sample[dir="snippets/plugins/plugin-tutorial/kotlin",files="plugin/src/main/kotlin/org/example/SlackBuildFlowAction.kt[]"]
include::sample[dir="snippets/plugins/plugin-tutorial/groovy",files="plugin/src/main/groovy/org/example/SlackBuildFlowAction.groovy[]"]
====

Currently, two of the three components of a Dataflow Action are complete:

1. The `SlackBuildFlowAction` class is a `FlowAction` that uses the Slack API to send a message at the end of a Gradle build:
2. The `SlackBuildFlowAction.Params` are `FlowParameters` that define the input parameters required by the flow action.

== Step 2. Registering a DataFlow Action

In the plugin's `apply()` method, you register the flow action like so:

[source,text]
----
getFlowScope().always(SlackBuildFlowAction) { spec ->
    spec.parameters.token.set(extension.token)
    spec.parameters.channel.set(extension.channel)
    spec.parameters.buildFailed.set(getFlowProviders().buildWorkResult.map { it.failure.isPresent() })
}
----

This tells Gradle: when the build finishes, execute this Slack flow action with these parameters.
This takes care of the final component of our flow action, the `FlowScope`.

Copy the code so your plugin class looks as follows:

====
include::sample[dir="snippets/plugins/plugin-tutorial/kotlin",files="plugin/src/main/kotlin/org/example/SlackPlugin.kt[tags=final]"]
include::sample[dir="snippets/plugins/plugin-tutorial/groovy",files="plugin/src/main/groovy/org/example/SlackPlugin.groovy[tags=final]"]
====

In our plugin class, we ask Gradle to inject two objects at runtime:

* **`FlowScope`** – Lets the plugin register actions that run automatically during the build lifecycle. In this case, it is used to register our `SlackBuildFlowAction` class.
* **`FlowProviders`** – Supplies data (like build success/failure) to those actions. In this case, it is used as an input to our `SlackBuildFlowAction` class.

Both are used to hook Slack notifications into the build without manually adding listeners.

[.text-right]
**Next Step:** <<part6_functional_test.adoc#part6_functional_test,Write a Functional Test>> >>
