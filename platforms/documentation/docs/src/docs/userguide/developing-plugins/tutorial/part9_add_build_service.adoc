// Copyright (C) 2024 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[part9_add_build_service]]
= Part 9: Add a Build Service

Learn the basics of authoring Gradle tasks by creating a simple one in your Build script.

****
**In this section, you will:**

- Understand Build Services
- Add a Build Service to the Plugin
****

[[part9_begin]]
== Step 0. Before you Begin

1. You initialized your plugin in <<part1_gradle_init_plugin.adoc#part1_begin,part 1>>.
2. You added an extension to your plugin in <<part2_add_extension.adoc#part2_begin,part 2>>.
3. You created a custom task in <<part3_create_custom_task.adoc#part3_begin, part3>>.
4. You wrote a unit test in <<part4_unit_test.adoc#part4_begin,part 4>>.
5. You added a dataflow action to your plugin in <<part5_add_dataflow_action.adoc#part5_begin,part 2>>.
6. You wrote a functional test in <<part6_functional_test.adoc#part6_begin,part 6>>.
7. You used a dummy consumer project to consume your plugin in <<part7_use_consumer_project.adoc#part7_begin,part 7>>.
8. You replaced the dataflow action with a build listener in <<part8_add_build_listener.adoc#part8_begin,part 8>>.

== Step 1. Understanding Build Services

Evolving the plugin from using a `BuildListener` to a `BuildService` is a smart move for cleaner design and better integration with Gradle’s lifecycle and caching system.

A Build Service in Gradle is a way to define shared, long-lived logic or state that can be used throughout the build lifecycle, in a clean and managed way.
It is essentially a Gradle-managed singleton that can be safely reused by tasks or plugins during the build.

It’s:

- Reusable across tasks and projects
- Configurable using input parameters
- Lifecycle-aware: `close()` is automatically called after the build
- Isolated: can be run in the configuration or execution phase
- Efficient: avoids duplicated setup (e.g., setting up an API client, caching state, tracking changes)

Congratulations, you have completed the tutorial!
