// Copyright (C) 2024 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[part6_functional_test]]
= Part 6: Writing a Functional Test

Learn the basics of functional testing your plugin.

****
**In this section, you will:**

- Write a Functional Test for your plugin
- Run a Functional Test to test your plugin
****

[[part6_begin]]
== Step 0. Before you Begin

1. You initialized your plugin in <<part1_gradle_init_plugin.adoc#part1_begin,part 1>>.
2. You added an extension to your plugin in <<part2_add_extension.adoc#part2_begin,part 2>>.
3. You created a custom task in <<part3_create_custom_task.adoc#part3_begin, part3>>.
4. You wrote a unit test in <<part4_unit_test.adoc#part4_begin,part 4>>.
5. You added a dataflow action to your plugin in <<part5_add_dataflow_action.adoc#part5_begin,part 2>>.

== Step 1. About Functional Tests

Grade init provides a sample functional test that we can reuse.
It is available in `src/functionalTest/kotlin/org/example/SlackPluginTest.kt`.
Let's take a look:

[source,kotlin]
----
/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import java.io.File
import kotlin.test.assertTrue
import kotlin.test.Test
import org.gradle.testkit.runner.GradleRunner
import org.junit.jupiter.api.io.TempDir

/**
 * A simple functional test for the 'org.example.greeting' plugin.
 */
class DevelopingPluginPluginFunctionalTest {

    @field:TempDir
    lateinit var projectDir: File

    private val buildFile by lazy { projectDir.resolve("build.gradle") }
    private val settingsFile by lazy { projectDir.resolve("settings.gradle") }

    @Test fun `can run task`() {
        // Set up the test build
        settingsFile.writeText("")
        buildFile.writeText("""
            plugins {
                id('org.example.greeting')
            }
        """.trimIndent())

        // Run the build
        val runner = GradleRunner.create()
        runner.forwardOutput()
        runner.withPluginClasspath()
        runner.withArguments("greeting")
        runner.withProjectDir(projectDir)
        val result = runner.build()

        // Verify the result
        assertTrue(result.output.contains("Hello from plugin 'org.example.greeting'"))
    }
}
----

This functional test uses Gradle <<test_kit.adoc#test_kit,TestKit>> to verify that the `org.example.greeting` plugin works in a real Gradle build.
Gradle `TestKit` is a built-in Gradle testing framework.
Instead of just unit testing your plugin’s classes in isolation, `TestKit` spins up an actual Gradle build (in a temporary directory) and runs it.
Exactly like a real user would.
This way, you can verify that your plugin behaves correctly when applied to a real project.

First, it sets up a temporary project directory:

[source,kotlin]
----
@field:TempDir lateinit var projectDir: File
----

`JUnit` creates a fresh, empty directory for each test run so the build runs in isolation.

Then, it creates a build file and a settings file:

[source,kotlin]
----
   private val buildFile by lazy { projectDir.resolve("build.gradle") }
   private val settingsFile by lazy { projectDir.resolve("settings.gradle") }
----

The test writes a minimal build script and keeps the settings file empty:

[source,kotlin]
----
settingsFile.writeText("")
buildFile.writeText("""
   plugins {
       id('org.example.greeting')
   }
""".trimIndent())
----

This is where you can define any build logic you want to test.
Essentially, you can model any realistic project setup directly in your test.

Then, it creates a barebones Gradle project that applies the plugin under test using the `GradleRunner`:

[source,kotlin]
----
val runner = GradleRunner.create()
   .forwardOutput()
   .withPluginClasspath()
   .withArguments("greeting")
   .withProjectDir(projectDir)
val result = runner.build()
----

`GradleRunner` is the main API class in `TestKit` that actually runs a Gradle build from your test code.
When you call `GradleRunner.create()`, you’re instantiating a new Gradle process in-process for your test.
This process runs in an isolated environment, using the `projectDir` you give it as the root of the build.

Finally, the functional test verifies the output:

[source,kotlin]
----
assertTrue(result.output.contains("Hello from plugin 'org.example.greeting'"))
----

This confirms the plugin’s task actually ran and printed the expected message.

We are also going to re-use a majority of this test.

== Step 2. Update the Test

First, update the name of the file from `DevelopingPluginPluginFunctionalTest.kt` to `SlackPluginFunctionalTest.kt`.

Second, update your test so it looks as follows:

[source,kotlin]
----
package org.example

import java.io.File
import kotlin.test.assertTrue
import kotlin.test.Test
import org.gradle.testkit.runner.GradleRunner
import org.junit.jupiter.api.io.TempDir

class SlackPluginFunctionalTest {

    @field:TempDir
    lateinit var projectDir: File

    private val buildFile by lazy { projectDir.resolve("build.gradle") }
    private val settingsFile by lazy { projectDir.resolve("settings.gradle") }

    @Test fun `can run task`() {
        // Set up the test build
        settingsFile.writeText("")
        buildFile.writeText("""
            plugins {
                id('org.example.slack')
            }
        """.trimIndent())

        // Run the build
        val runner = GradleRunner.create()
        runner.forwardOutput()
        runner.withPluginClasspath()
        runner.withArguments("slack")
        runner.withProjectDir(projectDir)
        val result = runner.build()

        // Verify the result
        //assertTrue(result.output.contains("Hello from plugin 'org.example.greeting'"))
    }
}
----

This test ....

== Step 3. Check out the Build File

It's important to look at the build file:

[source,kotlin]
----
// Add a source set for the functional test suite
val functionalTestSourceSet = sourceSets.create("functionalTest") {
}

configurations["functionalTestImplementation"].extendsFrom(configurations["testImplementation"])
configurations["functionalTestRuntimeOnly"].extendsFrom(configurations["testRuntimeOnly"])

// Add a task to run the functional tests
val functionalTest by tasks.registering(Test::class) {
    testClassesDirs = functionalTestSourceSet.output.classesDirs
    classpath = functionalTestSourceSet.runtimeClasspath
    useJUnitPlatform()
}

gradlePlugin.testSourceSets.add(functionalTestSourceSet)

tasks.named<Task>("check") {
    // Run the functional tests as part of `check`
    //dependsOn(functionalTest)
}

tasks.named<Test>("test") {
    // Use JUnit Jupiter for unit tests.
    useJUnitPlatform()
}
----

This creates...

== Step 4. Run the Functional Test

Then, you can run the `check` task and ensure it passes.

[source,text]
----
$ ./gradlew :check

...
----

[.text-right]
**Next Step:** <<part7_use_consumer_project#part7_use_consumer_project,Use a Consumer Project>> >>
