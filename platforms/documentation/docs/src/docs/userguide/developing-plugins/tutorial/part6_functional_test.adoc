// Copyright (C) 2024 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[part6_functional_test]]
= Part 6: Writing a Functional Test

Learn the basics of functional testing your plugin.

****
**In this section, you will:**

- Write a Functional Test for your plugin
- Run a Functional Test to test your plugin
****

[[part6_begin]]
== Step 0. Before you Begin

1. You initialized your plugin in <<part1_gradle_init_plugin.adoc#part1_begin,part 1>>.
2. You added an extension to your plugin in <<part2_add_extension.adoc#part2_begin,part 2>>.
3. You created a custom task in <<part3_create_custom_task.adoc#part3_begin, part3>>.
4. You wrote a unit test in <<part4_unit_test.adoc#part4_begin,part 4>>.
5. You added a dataflow action to your plugin in <<part5_add_dataflow_action.adoc#part5_begin,part 2>>.

== Step 1. About Functional Tests

Grade init provides a sample functional test that we can reuse.
[.multi-language-text.lang-kotlin]
----
It is available in `src/functionalTest/kotlin/org/example/PluginTutorialPluginFunctionalTest.kt`.
----
[.multi-language-text.lang-groovy]
----
It is available in `src/functionalTest/groovy/org/example/PluginTutorialPluginFunctionalTest.groovy`.
----
Let's take a look:

====
include::sample[dir="snippets/plugins/plugin-tutorial/kotlin",files="plugin/src/functionalTest/kotlin/org/example/PluginTutorialPluginFunctionalTest.kt[tags=init-test]"]
include::sample[dir="snippets/plugins/plugin-tutorial/groovy",files="plugin/src/functionalTest/groovy/org/example/PluginTutorialPluginFunctionalTest.groovy[tags=init-test]"]
====

This functional test uses Gradle <<test_kit.adoc#test_kit,TestKit>> to verify that the `org.example.greeting` plugin works in a real Gradle build.
Gradle `TestKit` is a built-in Gradle testing framework.
Instead of just unit testing your plugin’s classes in isolation, `TestKit` spins up an actual Gradle build (in a temporary directory) and runs it.
Exactly like a real user would.
This way, you can verify that your plugin behaves correctly when applied to a real project.

First, it sets up a temporary project directory:

[source,text]
----
@field:TempDir lateinit var projectDir: File
----

`JUnit` creates a fresh, empty directory for each test run so the build runs in isolation.

Then, it creates a build file and a settings file:

[source,text]
----
private val buildFile by lazy { projectDir.resolve("build.gradle") }
private val settingsFile by lazy { projectDir.resolve("settings.gradle") }
----

The test writes a minimal build script and keeps the settings file empty:

[source,text]
----
settingsFile.writeText("")
buildFile.writeText("""
   plugins {
       id('org.example.greeting')
   }
""".trimIndent())
----

This is where you can define any build logic you want to test.
Essentially, you can model any realistic project setup directly in your test.

Then, it creates a barebones Gradle project that applies the plugin under test using the `GradleRunner`:

[source,text]
----
val runner = GradleRunner.create()
   .forwardOutput()
   .withPluginClasspath()
   .withArguments("greeting")
   .withProjectDir(projectDir)
val result = runner.build()
----

`GradleRunner` is the main API class in `TestKit` that actually runs a Gradle build from your test code.
When you call `GradleRunner.create()`, you’re instantiating a new Gradle process in-process for your test.
This process runs in an isolated environment, using the `projectDir` you give it as the root of the build.

Finally, the functional test verifies the output:

[source,text]
----
assertTrue(result.output.contains("Hello from plugin 'org.example.greeting'"))
----

This confirms the plugin’s task actually ran and printed the expected message.

We are also going to re-use a majority of this test.

== Step 2. Update the Test

[.multi-language-text.lang-kotlin]
----
First, update the name of the file from `PluginTutorialPluginFunctionalTest.kt` to `SlackPluginFunctionalTest.kt`.
----
[.multi-language-text.lang-groovy]
----
First, update the name of the file from `PluginTutorialPluginFunctionalTest.groovy` to `SlackPluginFunctionalTest.groovy`.
----

Second, update your test so it looks as follows:

====
include::sample[dir="snippets/plugins/plugin-tutorial/kotlin",files="plugin/src/functionalTest/kotlin/org/example/SlackPluginFunctionalTest.kt[]"]
include::sample[dir="snippets/plugins/plugin-tutorial/groovy",files="plugin/src/functionalTest/groovy/org/example/SlackPluginFunctionalTest.groovy[]"]
====

This functional test:

1. **Creates a temporary test project** (`@TempDir`), including `settings.gradle` and `build.gradle` files.
2. **Applies the Slack plugin** in `build.gradle` and configures it with a token, channel, and message.
3. **Runs the build programmatically** using `GradleRunner` with the plugin’s classpath.
4. **Verifies the result** by asserting that the build output contains `"Slack message sent successfully"`.

== Step 3. Check out the Build File

It's important to look at the build file of our plugin before we can run our functional test, specifically the test related build logic:

====
include::sample[dir="snippets/plugins/plugin-tutorial/kotlin",files="plugin/build.gradle.kts[tags=test-config]"]
include::sample[dir="snippets/plugins/plugin-tutorial/groovy",files="plugin/build.gradle[tags=test-config]"]
====

This logic sets up a **separate functional test suite** for the plugin.
It:

* Creates a new `functionalTest` source set (`src/functionalTest/...`) for end-to-end plugin tests.
* Inherits dependencies from the normal `test` setup.
* Registers a `functionalTest` task that runs these tests with JUnit 5.
* Configures Gradle so TestKit is available for them.
* Optionally wires `functionalTest` into the `check` lifecycle task.

== Step 4. Run the Functional Test

As you can see from the code in the functional test, the Slack token is retrienve from the environment variable `SLACK_TOKEN`.
You need to set this variable before you run the test:

[source,text]
----
$ export SLACK_TOKEN="xoxb-..."
----

Then, you can run the `functionalTest` task and ensure it passes:

[source,text]
----
$ ./gradlew :functionalTest

> Task :plugin:functionalTest

BUILD SUCCESSFUL in 4s
6 actionable tasks: 1 executed, 5 up-to-date
----

Make sure your Slack message is sent in your Slack Workspace `#social` channel.

You can also run the `check` task.

[.text-right]
**Next Step:** <<part7_use_consumer_project#part7_use_consumer_project,Use a Consumer Project>> >>
