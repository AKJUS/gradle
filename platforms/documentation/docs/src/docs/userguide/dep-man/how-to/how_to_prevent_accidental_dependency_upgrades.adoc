// Copyright 2025 Gradle and contributors.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[how_to_prevent_accidental_dependency_upgrades]]
= How to Prevent Accidental Dependency Upgrades in Gradle

This guide explains how to **prevent accidental dependency versions** from your project.
This guide explains how to prevent such upgrades and maintain strict control over dependency versions.

== Why Prevent Dependency Upgrades?

When managing dependencies in Gradle, you may encounter situations where transitive dependencies cause **unexpected upgrades** to newer versions.
This can lead to unintended behavior or compatibility issues.
Gradle, by default, performs _optimistic upgrades_, meaning it resolves to the highest available version when multiple versions of a dependency are found in the dependency graph.

For example, if both `1.1` and `1.3` versions of `commons-lang3` are present, Gradle will select `1.3`, even if your build script explicitly declares `1.1`.
If your build uses a feature available in version `1.1` but not `1.3`, or if you haven't updated your build to be compatible with version `1.3`, you may not want this eager upgrade from Gradle's dependency resolution process.

== Enforce Strict Dependency Resolution

Gradle provides an option to **fail the build when a version conflict occurs**, ensuring that no unintended upgrades happen.

To enable this, configure your build to **fail on version conflicts**:

[source,kotlin]
----
configurations.all {
    resolutionStrategy.failOnVersionConflict()
}
----

[source,groovy]
----
configurations.all {
    resolutionStrategy.failOnVersionConflict()
}
----

When this setting is enabled, Gradle will stop execution and report an error if multiple versions of a dependency conflict, instead of automatically upgrading to the highest version.

== Declaring Explicit Versions

Another way to prevent accidental upgrades is by **explicitly declaring dependency versions** in your build script.

Example:

[source,kotlin]
----
dependencies {
    implementation("org.apache.commons:commons-lang3:1.1")
}
----

[source,groovy]
----
dependencies {
    implementation 'org.apache.commons:commons-lang3:1.1'
}
----

By specifying the version explicitly, you ensure that Gradle does not resolve to a newer transitive version unless explicitly updated.

== Using Dependency Constraints

If you have multiple dependencies that use a shared library, you can enforce a consistent version across all modules using **dependency constraints**:

[source,kotlin]
----
dependencies {
    implementation("org.apache.commons:commons-lang3")
    constraints {
        implementation("org.apache.commons:commons-lang3") {
            version {
                strictly("1.1")
            }
        }
    }
}
----

[source,groovy]
----
dependencies {
    implementation 'org.apache.commons:commons-lang3'
    constraints {
        implementation('org.apache.commons:commons-lang3') {
            version {
                strictly '1.1'
            }
        }
    }
}
----

With `strictly("1.1")`, Gradle ensures that no other version can override the specified dependency.

== Step 5: Locking Dependencies to Specific Versions

For a more robust solution, you can use **dependency locking** to ensure Gradle resolves the same dependency versions consistently across builds.

To enable dependency locking:

[source,kotlin]
----
configurations.all {
    resolutionStrategy.activateDependencyLocking()
}
----

[source,groovy]
----
configurations.all {
    resolutionStrategy.activateDependencyLocking()
}
----

Then, generate a lock file:
[source,bash]
----
./gradlew dependencies --write-locks
----

This creates a `gradle.lockfile` that stores the exact dependency versions, preventing future upgrades unless explicitly updated.

== Summary

By following these steps, you can ensure that your Gradle builds remain predictable and **free from accidental dependency upgrades**.
Using `failOnVersionConflict()`, explicit version declarations, constraints, and dependency locking gives you complete control over the dependency resolution process.

For further reading, refer to Gradle's documentation on <<dependency_locking.adoc#sec:dependency-locking,Dependency Locking>>.
