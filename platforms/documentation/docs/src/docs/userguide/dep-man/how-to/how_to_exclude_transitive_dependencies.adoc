// Copyright 2025 Gradle and contributors.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[how_to_exclude_transitive_dependencies]]
== How to Exclude Transitive Dependencies

This guide explains how to **exclude transitive dependencies** from your project when they are not needed or cause conflicts.

=== When to Exclude Transitive Dependencies

Excluding a transitive dependency should be a **conscious decision**, as removing required dependencies may lead to **runtime errors** if a library depends on them.
Before excluding, ensure:
âœ… Your application does not require the excluded dependency.
âœ… You have sufficient **test coverage** to verify that excluding the dependency does not break functionality.

Exclusions are useful when:
* A **library includes unnecessary transitive dependencies** that are not required by your application.
* You need to **reduce the size of your dependencies**.
* A **dependency conflict** exists and must be resolved differently.

---

=== Excluding a Transitive Dependency

You can exclude a transitive dependency **per dependency declaration** by specifying the `group` and `module` attributes.

==== Example: Exclude a Transitive Dependency

[source,groovy]
.build.gradle
----
dependencies {
    implementation("commons-beanutils:commons-beanutils:1.9.4") {
        exclude(group = "commons-collections", module = "commons-collections")
    }
}
----

ðŸ”¹ This removes `commons-collections` from the transitive dependencies of `commons-beanutils`.
ðŸ”¹ The exclusion only applies to **this specific dependency**.

If your application only uses **a subset** of the library that does not require the excluded dependency, this approach is safe.

---

=== Understanding the Impact of Exclusions

Exclusions **only apply if all dependency declarations agree** on the exclusion.
If another dependency in your project **still requires** the excluded dependency, Gradle **will not exclude it**.

==== Example: When an Exclusion is Overridden

[source,groovy]
.build.gradle
----
dependencies {
    implementation("commons-beanutils:commons-beanutils:1.9.4") {
        exclude(group = "commons-collections", module = "commons-collections")
    }
    implementation("com.opencsv:opencsv:4.6") // Depends on 'commons-beanutils' but does NOT exclude 'commons-collections'
}
----

ðŸš¨ In this case, `commons-collections` is **still included** because `opencsv` brings it back.
âœ… To **fully exclude** `commons-collections`, you must also exclude it from `opencsv`.

==== Example: Exclude a Transitive Dependency for Multiple Dependencies

[source,groovy]
.build.gradle
----
dependencies {
    implementation("commons-beanutils:commons-beanutils:1.9.4") {
        exclude(group = "commons-collections", module = "commons-collections")
    }
    implementation("com.opencsv:opencsv:4.6") {
        exclude(group = "commons-collections", module = "commons-collections")
    }
}
----

ðŸ”¹ Now `commons-collections` is **fully excluded** from all dependencies that reference it.

---

=== Alternative Approaches to Dependency Management

Before using exclusions, consider whether **other Gradle features** are better suited for resolving dependency conflicts:

âœ… **Use Dependency Constraints**
If a dependency version conflict occurs, **adjust the version using a constraint** rather than excluding the dependency entirely.

âœ… **Apply Component Metadata Rules**
If a dependency is **incorrectly declared** in metadata (e.g., includes an unnecessary compile-time dependency),
you can **remove the dependency in a component metadata rule** instead of excluding it.

âœ… **Resolve Mutually Exclusive Dependency Conflicts**
If multiple dependencies **conflict** because they represent different implementations of the same feature
(e.g., `log4j` vs. `log4j-over-slf4j`), it is better to **define component capabilities** than to exclude one implementation.

---

=== Summary

âœ… **Use exclusions only when necessary** to avoid runtime errors.
âœ… **Ensure all dependencies agree** on an exclusion for it to be effective.
âœ… **Consider alternative Gradle features** like dependency constraints or metadata rules before excluding.

By managing transitive dependencies carefully, you can **reduce conflicts, optimize dependencies, and maintain stability** in your builds. ðŸš€
