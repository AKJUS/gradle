// Copyright (C) 2024 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[writing_build_scripts]]
= Authoring Build Scripts

The initialization phase in the Gradle Build lifecycle finds the root project and subprojects included in your <<directory_layout#dir:project_root,project root directory>> using the settings file.

For each project included in the settings file, Gradle creates a link:{javadocPath}/org/gradle/api/Project.html[`Project`] instance.
Gradle then looks for a corresponding build file, which is used during the configuration phase to configure the `Project` object.

== Anatomy of a Build Script

Gradle build scripts are written in either <<groovy_build_script_primer.adoc#groovy_build_script_primer, Groovy DSL>> or <<kotlin_dsl.adoc#kotdsl:kotlin_dsl, Kotlin DSL>> (domain-specific language).
The build script is either a `\*.gradle` file in Groovy or a `*.gradle.kts` file in Kotlin.

As a build script executes, it configures a link:{javadocPath}/org/gradle/api/Project.html[`Project`] object and its children.

image::author-gradle-4.png[Build,500,63,align="left"]

=== Script Structure

A Gradle build script consists of two main types of elements:

1. *Statements*: Top-level expressions that execute immediately during the configuration phase.
2. *Blocks*: Nested sections (_closures_ or _lambdas_) passed to configuration methods that apply settings to Gradle objects.

Examples of common blocks include:

====
include::sample[dir="snippets/multiproject/basic-dependencies/kotlin",files="api/build.gradle.kts[]"]
include::sample[dir="snippets/multiproject/basic-dependencies/groovy",files="api/build.gradle[]"]
====

Each block corresponds to a method on the Project API and is evaluated with a *delegate* or *receiver* (more on that below).

=== Closures and Lambdas

Gradle scripts are based on dynamic _closures_ in Groovy or static _lambdas_ in Kotlin:

- In Groovy, blocks are _closures_, and Gradle dynamically *delegates* method/property calls to a target object.
- In Kotlin, blocks are _lambdas_ with *receivers*, and Gradle statically types the `this` object inside the block.

This delegation allows concise configuration:

[source,groovy]
----
repositories {
    mavenCentral()
}
----

In this case, the `repositories {}` block is a method call where the _closure_ configures a `RepositoryHandler` instance.

[source,kotlin]
----
repositories {
    mavenCentral()
}
----

In this case, the `repositories {}` block is a method call, and the _lambda_ configures a `RepositoryHandler` instance.
Inside the block, `mavenCentral()` is a method on that *receiver*, so no qualifier is needed.

=== Delegates and Receivers

Every configuration block executes in the context of an object:

- In Groovy, this is the block's *delegate*.
- In Kotlin, this is the block's *receiver*.

Inside the `dependencies {}` block, for instance, the `implementation(...)` method is delegated to the `DependencyHandler`:

[source,kotlin]
----
dependencies {
    implementation("org.jetbrains.kotlin:kotlin-stdlib")
}
----

This behavior allows intuitive configuration but can sometimes obscure where a method is coming from.
For clarity, you can use explicit references like `project.dependencies.implementation(...)`.

=== Line-by-Line Execution

Gradle executes build scripts top to bottom during the configuration phase.
That means:

1. Code is evaluated immediately in order.
2. Statements outside of configuration blocks execute eagerly.
3. Properties and logic should be deferred using `Provider` or lazy APIs when possible (more on this in the next section).

This top-down execution model means the order of declarations can affect behavior, especially when using variables or configuring tasks.

== Core Building Blocks

Let's review core building blocks:

- `plugins {}` — Apply and manage plugins
- `repositories {}` — Where to resolve dependencies
- `dependencies {}` — What your build needs
- `tasks {}` — Registering and configuring work
- Properties and extensions (`group`, `version`, `application.mainClass`)
- Extra properties (`ext`, `extra`)

Now, let's take a look at an example and break it down:

====
include::sample[dir="snippets/plugins/simple/kotlin/sub-project-a", files="build.gradle.kts[]"]
include::sample[dir="snippets/plugins/simple/groovy/sub-project-a", files="build.gradle[]"]
====
<1> Apply plugins to the build.
<2> Define the locations where dependencies can be found.
<3> Add dependencies.
<4> Set properties.
<5> Register and configure tasks.

=== 1. Apply plugins to the build

Plugins are used to extend Gradle. They are also used to modularize and reuse project configurations.

Plugins can be applied using the `PluginDependenciesSpec` plugins script block.

The plugins block is preferred:

====
include::sample[dir="snippets/plugins/simple/kotlin/sub-project-a", files="build.gradle.kts[tags=plugins]"]
include::sample[dir="snippets/plugins/simple/groovy/sub-project-a", files="build.gradle[tags=plugins]"]
====

In the example, the `application` plugin, which is included with Gradle, has been applied, describing our project as a Java application.

=== 2. Define the locations where dependencies can be found

A project generally has a number of dependencies it needs to do its work.
Dependencies include plugins, libraries, or components that Gradle must download for the build to succeed.

The build script lets Gradle know where to look for the binaries of the dependencies.
More than one location can be provided:

====
include::sample[dir="snippets/plugins/simple/kotlin/sub-project-a", files="build.gradle.kts[tags=repo]"]
include::sample[dir="snippets/plugins/simple/groovy/sub-project-a", files="build.gradle[tags=repo]"]
====

In the example, the `guava` library and the JetBrains Kotlin plugin (`org.jetbrains.kotlin.jvm`) will be downloaded from the link:https://repo.maven.apache.org/maven2/[Maven Central Repository].

=== 3. Add dependencies

A project generally has a number of dependencies it needs to do its work.
These dependencies are often libraries of precompiled classes that are imported in the project's source code.

Dependencies are managed via <<glossary.adoc#sub:terminology_configuration,configurations>> and are retrieved from repositories.

Use the `DependencyHandler` returned by `Project.getDependencies()` method to manage the dependencies.
Use the `RepositoryHandler` returned by `Project.getRepositories()` method to manage the repositories.

====
include::sample[dir="snippets/plugins/simple/kotlin/sub-project-a", files="build.gradle.kts[tags=dep]"]
include::sample[dir="snippets/plugins/simple/groovy/sub-project-a", files="build.gradle[tags=dep]"]
====

In the example, the application code uses Google's `guava` libraries.
Guava provides utility methods for collections, caching, primitives support, concurrency, common annotations, string processing, I/O, and validations.

=== 4. Set properties

A plugin can add properties and methods to a project using extensions.

The link:{groovyDslPath}/org.gradle.api.Project.html[`Project`] object has an associated link:{javadocPath}/org/gradle/api/plugins/ExtensionContainer.html[`ExtensionContainer`] object that contains all the settings and properties for the plugins that have been applied to the project.

In the example, the `application` plugin added an `application` property, which is used to detail the main class of our Java application:

====
include::sample[dir="snippets/plugins/simple/kotlin/sub-project-a", files="build.gradle.kts[tags=app]"]
include::sample[dir="snippets/plugins/simple/groovy/sub-project-a", files="build.gradle[tags=app]"]
====

=== 5. Register and configure tasks

Tasks perform some basic piece of work, such as compiling classes, or running unit tests, or zipping up a WAR file.

While tasks are typically defined in plugins, you may need to register or configure tasks in build scripts.

*Registering* a task adds the task to your project.

You can register tasks in a project using the link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html[`TaskContainer.register(java.lang.String)`] method:

====
include::sample[dir="snippets/plugins/simple/kotlin/sub-project-a", files="build.gradle.kts[tags=task]"]
include::sample[dir="snippets/plugins/simple/groovy/sub-project-a", files="build.gradle[tags=task]"]
====

You may have seen usage of the link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html[`TaskContainer.create(java.lang.String)`] method *which should be avoided*.

[source,kotlin]
----
tasks.create<Zip>("zip-reports") { }
----

TIP: `register()`, which enables <<task_configuration_avoidance.adoc#task_configuration_avoidance,task configuration avoidance>>, is preferred over `create()`.

You can locate a task to configure it using the `TaskCollection.named(java.lang.String)` method:

====
include::sample[dir="snippets/plugins/simple/kotlin/sub-project-a", files="build.gradle.kts[tags=test]"]
include::sample[dir="snippets/plugins/simple/groovy/sub-project-a", files="build.gradle[tags=test]"]
====

The example below configures the link:{groovyDslPath}/org.gradle.api.tasks.javadoc.Javadoc.html[`Javadoc`] task to automatically generate HTML documentation from Java code:

====
include::sample[dir="snippets/plugins/simple/kotlin/sub-project-a", files="build.gradle.kts[tags=doc]"]
include::sample[dir="snippets/plugins/simple/groovy/sub-project-a", files="build.gradle[tags=doc]"]
====

== Working with the Project API

The `Project` object is part of the public Gradle APIs:

- In the Groovy DSL, the `Project` object documentation is found link:{groovyDslPath}/org.gradle.api.Project.html[here].
- In the Kotlin DSL, the `Project` object documentation is found link:{kotlinDslPath}/gradle/org.gradle.api/-project/index.html[here].

Many top-level properties and blocks in a build script are part of the link:{javadocPath}/org/gradle/api/Project.html[Project API].
For example, the following build script uses the link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:name[Project.name] property to print the name of the project:

====
include::sample[dir="snippets/tutorial/projectApi/kotlin",files="build.gradle.kts[tags=project-name]"]
include::sample[dir="snippets/tutorial/projectApi/groovy",files="build.gradle[tags=project-name]"]
----
$ gradle -q check
include::{snippetsPath}/tutorial/projectApi/tests/projectApi.out[]
----
====

Both `println` statements print out the same property.
The first uses the explicit, fully qualified way to access the project's link:{javadocPath}org/gradle/api/Project.html#getName()[`name`] property.
It’s always correct and unambiguous.

In a Groovy build script, `name` is often used without qualification because Gradle makes name a delegate to `project.name`.
This works because of Groovy’s dynamic resolution and Gradle's delegation model.

In a Kotlin build script, it also works because the script is compiled as an extension of the link:{javadocPath}/org/gradle/api/Project.html[`Project`] class, and `name` is a property on `Project`.

The link:{javadocPath}/org/gradle/api/Project.html[`Project`] object exposes a standard set of properties in your build script.

The following table lists a few commonly used properties:

[%header%autowidth,compact]
|===
| Name | Type | Description

| `name`
| `String`
| The name of the project directory.

| `path`
| `String`
| The fully qualified name of the project.

| `description`
| `String`
| A description for the project.

| `dependencies`
| `DependencyHandler`
| Returns the dependency handler of the project.

| `repositories`
| `RepositoryHandler`
| Returns the repository handler of the project.

| `layout`
| `ProjectLayout`
| Provides access to several important locations for a project.

| `group`
| `Object`
| The group of this project.

| `version`
| `Object`
| The version of this project.
|===

The following table lists a few commonly used methods:

[%autowidth.stretch]
|===
| Name | Description

| `uri()`
| Resolves a file path to a URI, relative to the project directory of this project.

| `task()`
| Creates a Task with the given name and adds it to this project.
|===

It's a good idea to check out the Javadocs for link:{javadocPath}/org/gradle/api/Project.html[`Project`] if you haven't done so already to familiarize yourself with an important Gradle API.

[[script-default-imports]]
== Script Defaults & Imports

To make build scripts more concise, Gradle automatically adds a set of import statements to scripts.

As a result, instead of writing `throw new org.gradle.api.tasks.StopExecutionException()`, you can write `throw new StopExecutionException()`.

Gradle implicitly adds the following imports to each script:

[source,groovy]
----
include::default-imports.txt[]
----

[[sec:build_script_external_dependencies]]
[[sec:configuring_arbitrary_objects_using_an_external_script]]
[[sec:closures_as_the_last_parameter_in_a_method]]

[.text-right]
**Next Step:** <<gradle_managed_types.adoc#gradle_types_intro,Learn about Gradle Managed Types>> >>
