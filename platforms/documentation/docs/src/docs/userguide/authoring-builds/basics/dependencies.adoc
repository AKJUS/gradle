// Copyright (C) 2024 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[dependencies_intro]]
= Declaring and Managing Dependencies

Gradle provides a rich model for managing dependencies, resolving conflicts, and enforcing consistency.

image::gradle-basic-13.png[]

== Dependencies Block

The dependencies block in Gradle is where you declare the external libraries, internal modules, and files your project needs to compile, run, or test.
Itâ€™s one of the most central parts of any Gradle build script:

====
include::sample[dir="snippets/dependencyManagement/declaringDependencies-basic/kotlin/app",files="build.gradle.kts[tags=java-dependency-mgmt]"]
include::sample[dir="snippets/dependencyManagement/declaringDependencies-basic/groovy/app",files="build.gradle[tags=java-dependency-mgmt]"]
====

Dependencies are associated with configurations, which define the context in which the dependency is used.
For example, `implementation` is used for main source code at compile and runtime, while `debugImplementation` is specific to debugging builds in Android.

However, Gradle's dependency management ecosystem offers much more than just declaring dependencies.

== Version Catalogs (`libs.versions.toml`)

Gradle provides version catalogs which are the recommended way to *centralize dependency versions*.
They can act as the single source of truth across all of your dependency declarations and are easily shared across projects.

With the following `gradle/libs.versions.toml` version catalog:

====
include::sample[dir="snippets/init/generated/groovy",files="gradle/libs.versions.toml[]"]
====

Dependencies are accessed in your build script as follows:

====
include::sample[dir="snippets/init/generated/kotlin",files="app/build.gradle.kts[tags=init-dep]"]
include::sample[dir="snippets/init/generated/groovy",files="app/build.gradle[tags=init-dep]"]
====

== Declare Constraints and Enforce Versions

Gradle lets you **constrain versions** to avoid unwanted upgrades or resolve conflicts deterministically.

====
include::sample[dir="snippets/how-to/downgrade-transitives/kotlin",files="build.gradle.kts[tags=dependency-full]"]
include::sample[dir="snippets/how-to/downgrade-transitives/groovy",files="build.gradle[tags=dependency-full]"]
====

You can also constrain a module globally:

====
include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-versionsWithConstraints/kotlin",files="build.gradle.kts[tags=dependency-constraints]"]
include::sample[dir="snippets/dependencyManagement/managingTransitiveDependencies-versionsWithConstraints/groovy",files="build.gradle[tags=dependency-constraints]"]
====

== Declare Capabilities to Resolve Conflicts

Some modules provide **the same functionality** but under different coordinates (e.g., shaded libraries or alternatives).
Gradle lets you resolve these using **capabilities**.

Consider a case where two libraries, `jaxen` and `jdom2`, both claim to provide XPath support:

[source,kotlin]
----
dependencies {
    implementation("jaxen:jaxen:1.1.6")     // Transitive dependency that brings XPath functionality
    implementation("org.jdom:jdom2:2.0.6")  // Also offers XPath functionality
}

----

This might lead to duplicate or conflicting classes on the classpath.

To prevent this, you can declare a common capability and explicitly require only one implementation:

[source,kotlin]
----
dependencies {
    implementation("jaxen:jaxen:1.1.6") {
        capabilities {
            requireCapability("xml:xpath-support")
        }
    }
    implementation("org.jdom:jdom2:2.0.6")
}
----

In the same build file, use component metadata rules to assign a common capability to both libraries:

[source,kotlin]
----
components {
    withModule("jaxen:jaxen") {
        allVariants {
            withCapabilities {
                addCapability("xml", "xpath-support", "1.0")
            }
        }
    }
    withModule("org.jdom:jdom2") {
        allVariants {
            withCapabilities {
                addCapability("xml", "xpath-support", "1.0")
            }
        }
    }
}
----

Gradle now understands that both modules provide `xml:xpath-support:1.0` and will select only one.
Since you used `requireCapability` on `jaxen`, it will include that and exclude `jdom2`, avoiding conflict.

If both were declared without disambiguation, Gradle would fail the build, asking you to choose between the conflicting capabilities.

There are many more ways to influence dependency resolution in Gradle.
Consult the <<getting_started_dep_man.adoc#dependency-management-in-gradle,Dependency Management>> chapter to learn more.

[.text-right]
**Next Step:** <<writing_tasks.adoc#writing_tasks,Learn about Creating and Registering Tasks>> >>
