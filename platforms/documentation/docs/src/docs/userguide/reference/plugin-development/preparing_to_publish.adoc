// Copyright (C) 2025 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[preparing_to_publish_plugins]]
= Preparing to Publish Plugins

In order to share a Gradle plugin with others, you must package it into JAR files and generate the accompanying metadata so that other builds can resolve and apply it.

Gradle’s publishing plugins add tasks and conventions to help you prepare artifacts and metadata for distribution to repositories such as a local Maven repository, Maven Central, JFrog Artifactory, or the Gradle Plugin Portal.

== Applying a Publishing Plugin

To get started, apply one or more publishing plugins in your plugin project:

- Use the link:https://plugins.gradle.org/plugin/com.gradle.plugin-publish[Plugin Publishing Plugin] for the Gradle Plugin Portal.
- Use the <<publishing_maven.adoc#publishing_maven,Maven Publish Plugin>> for Maven repositories (e.g., Maven Central, Artifactory, GitHub Packages).
- Use the <<publishing_ivy.adoc#publishing_ivy,Ivy Publish Plugin>> for Ivy repositories.

[source,text]
----
plugins {
    id("maven-publish")                                         // Maven
    id("ivy-publish")                                           // Ivy
    id("com.gradle.plugin-publish") version "<latest-version>"  // Plugin Portal
}
----

Applying a publishing plugin registers tasks that assemble your plugin’s JARs and generate metadata files (POM, Gradle Module Metadata, plugin markers).

== Minimum Configuration

A plugin project must at least declare:

- A **plugin ID** and **implementation class** (so Gradle knows what to apply).
- A **group** and **version** (so the plugin can be published and resolved like any other dependency).

====
include::sample[dir="snippets/developingPlugins/pluginWithVariants/kotlin",files="build.gradle.kts[tags=publish-1]"]
include::sample[dir="snippets/developingPlugins/pluginWithVariants/groovy",files="build.gradle[tags=publish-1]"]
====

This setup lets Gradle generate plugin marker artifacts (`org.example.greeting.gradle.plugin`) and other metadata required by repositories and consumers.

== Local Publishing and Testing

To test your plugin before publishing to a remote repository, publish it to a local Maven directory:

====
include::sample[dir="snippets/developingPlugins/pluginWithVariants/kotlin",files="build.gradle.kts[tags=publish-2]"]
include::sample[dir="snippets/developingPlugins/pluginWithVariants/groovy",files="build.gradle[tags=publish-2]"]
====

Run:

[source,bash]
----
./gradlew publish
----

Gradle writes plugin artifacts and metadata to `build/local-repo`:

[source,text]
----
build/local-repo/
└── org/
    └── example/
        ├── greeting/
        │   └── 1.0.0/
        │       ├── greeting-1.0.0.jar                 // compiled plugin classes
        │       ├── greeting-1.0.0.jar.sha1            // checksum (SHA-1) for integrity verification
        │       ├── greeting-1.0.0.jar.sha256          // checksum (SHA-256) for stronger integrity verification
        │       ├── greeting-1.0.0.module              // Gradle Module Metadata (variants, capabilities, dependencies)
        │       ├── greeting-1.0.0.module.sha1
        │       ├── greeting-1.0.0.module.sha256
        │       ├── greeting-1.0.0.pom                 // Maven POM: group, artifact, version, dependencies
        │       ├── greeting-1.0.0.pom.sha1
        │       ├── greeting-1.0.0.pom.sha256
        │       └── greeting-1.0.0-sources.jar         // optional sources JAR (if withSourcesJar() is enabled)
        │           ├── greeting-1.0.0-sources.jar.sha1
        │           └── greeting-1.0.0-sources.jar.sha256
        │
        └── org.example.greeting.gradle.plugin/
            └── 1.0.0/
                ├── org.example.greeting.gradle.plugin-1.0.0.module  // plugin marker metadata
                ├── org.example.greeting.gradle.plugin-1.0.0.module.sha1
                ├── org.example.greeting.gradle.plugin-1.0.0.module.sha256
                ├── org.example.greeting.gradle.plugin-1.0.0.pom     // plugin marker POM
                ├── org.example.greeting.gradle.plugin-1.0.0.pom.sha1
                └── org.example.greeting.gradle.plugin-1.0.0.pom.sha256
----

You’ll see:

- Plugin JAR(s) — compiled plugin classes.
- `pom` — Maven metadata with coordinates and dependencies.
- `.module` — Gradle Module Metadata with variant info.
- Plugin marker modules — let consumers apply your plugin by ID.
- Optional source JARs if `java { withSourcesJar() }` is configured.
- Hash files (`.sha1`, `.sha256`, etc.) for integrity checks.

To consume locally, point the consumer project’s `pluginManagement` to the local repo:

====
include::sample[dir="snippets/developingPlugins/pluginWithVariants/kotlin",files="settings.gradle.kts[tags=publish-3]"]
include::sample[dir="snippets/developingPlugins/pluginWithVariants/groovy",files="settings.gradle[tags=publish-3]"]
====

Now the consumer can apply your plugin by its `id` without pushing to a public repository.

== Validating

To validate your plugin before publishing:

[listing]
----
$ ./gradlew publishPlugins --validate-only
----
