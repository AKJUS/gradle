// Copyright (C) 2024 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[dependency_management_basics]]
= Dependencies and Dependency Management Basics

Gradle has built-in support for *dependency management*.

image::gradle-basic-7.png[]

Dependency management is an automated technique for declaring and resolving external resources required by a project (i.e., dependencies).

*Dependencies* include JARs, plugins, libraries, or source code that support building your project.
They *are declared in build scripts*.

Gradle automatically handles downloading, caching, and resolving these dependencies, saving you from managing them manually.
It also handles version conflicts and supports flexible version declarations.

== Declaring Your Dependencies

To add a dependency to your project, specify a dependency in the `dependencies {}` block of your `build.gradle(.kts)` file.

The following `build.gradle.kts` file adds a plugin and two dependencies to the project:

[source,kotlin]
----
plugins {
    id("com.android.application")             // <1>
}

dependencies {
    // Dependency on a remote binary to compile and run the code
    implementation("com.google.android.material:material:1.1.0-alpha05")   // <2>
    // Dependency on a remote binary to compile and run the test code
    testImplementation("org.mockito:mockito-core:2.16.0")                  // <3>
}
----
<1> Applies the Android Gradle plugin, which adds support for building Android apps.
<2> Adds a dependency on Material Design components used in production code.
<3> Adds a dependency on Mockito, used in test code to create mocks.

Dependencies in Gradle are grouped by *configurations*, which define when and how the dependency is used:

- `implementation` is used for dependencies needed to compile and run your production code.
- `testImplementation` is used for dependencies only required to compile and run your test code.

NOTE: Gradle supports many other configurations, such as `runtimeOnly`, `compileOnly`, `api`, and more.

== Viewing Project Dependencies

You can inspect the dependency tree using the `dependencies` task.
For example, to view the dependencies of the `:app` project:

[source,text]
----
$ ./gradlew :app:dependencies
----

Gradle will output the dependency tree, grouped by configuration:

[source,text]
----
$ ./gradlew :app:dependencies

> Task :app:dependencies

------------------------------------------------------------
Project ':app'
------------------------------------------------------------

implementation - Implementation only dependencies for source set 'main'. (n)
\--- com.google.android.material:material:1.1.0-alpha05 (n)

testImplementation - Implementation only dependencies for source set 'test'. (n)
\--- org.mockito:mockito-core:2.16.0 (n)

...
----

== Using a Version Catalog

A version catalog provides a centralized and consistent way to manage dependency coordinates and versions across your entire build.
Instead of declaring versions directly in each `build.gradle(.kts)` file, you define them once in a `libs.versions.toml` file.

This makes it easier to:

* Share common dependency declarations between subprojects
* Avoid duplication and version inconsistencies
* Enforce dependency and plugin versions across large projects

The version catalog typically contains four sections:

1. `[versions]` to declare the version numbers that plugins and libraries will reference.
2. `[libraries]` to define the libraries used in the build files.
3. `[bundles]` to define a set of dependencies.
4. `[plugins]` to define plugins.

Here's an example:

[source,gradle/libs.versions.toml]
----
[versions]
androidGradlePlugin = "7.4.1"
mockito = "2.16.0"

[libraries]
googleMaterial = { group = "com.google.android.material", name = "material", version = "1.1.0-alpha05" }
mockitoCore = { module = "org.mockito:mockito-core", version.ref = "mockito" }

[plugins]
androidApplication = { id = "com.android.application", version.ref = "androidGradlePlugin" }
----

Place this file in the `gradle/` directory of your project as `libs.versions.toml`.
Gradle will pick it up automatically and expose its contents through the `libs` accessor in your build scripts.
IDEs like IntelliJ and Android Studio will also pick up this metadata for code completion.

Once defined, you can reference these aliases directly in your build file:

[source,kotlin]
----
plugins {
   alias(libs.plugins.androidApplication)  // <1>
}

dependencies {
    implementation(libs.googleMaterial)    // <2>
    testImplementation(libs.mockitoCore)   // <3>
}
----
<1> Applies the Android Gradle plugin using the plugin alias.
<2> Adds the Material Design dependency using a library alias.
<3> Adds Mockito for use in test code.

To learn more, consult the <<glossary.adoc#dependency_management_terminology,Dependency Management chapter>>.

[.text-right]
**Next Step:** <<task_basics.adoc#task_basics,Learn about Tasks>> >>
